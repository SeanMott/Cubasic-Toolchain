#include <Cublic/PASMBackend.hpp>

//stores values from the old register we are going to use
static inline std::string StoreCurrentValueInRegister(const std::string& registerIndex)
{
	return "PUSH " + registerIndex + " ;we are storing a value from this register, so we can override it's register for other uses and not lose this data.\n";
}

//restore a value we stored away from it's register, returning it back to the register
static inline std::string ReturnValueBackToRegister(const std::string& registerIndex)
{
	return "POP " + registerIndex + " ;we are restoring a value to this register we stored earlier.\n";
}

//generates a list of PASM instructions
std::string Cube::Backend::PASM::GeneratePASM(const std::vector<AST::ASTNode>& AST, const CompilerSettings& settings)
{
	std::string str = "";

	//writes header
	str += "COMPILER_VERSION = " + settings.header.COMPILER_VERSION + "\n";
	str += "HEADER_CHIPSET = " + settings.header.HEADER_CHIPSET + "\n";
	str += "HEADER_LICENSEE = " + settings.header.HEADER_LICENSEE + "\n";
	str += "HEADER_MAGIC = " + settings.header.HEADER_MAGIC + "\n";
	str += "HEADER_RAMSIZE = " + settings.header.HEADER_RAMSIZE + "\n";
	str += "HEADER_ROMSIZE = " + settings.header.HEADER_ROMSIZE + "\n";
	str += "HEADER_RULEBREAKER = " + settings.header.HEADER_RULEBREAKER + "\n";
	str += "HEADER_TITLE = " + settings.header.HEADER_TITLE + "\n";
	str += "HEADER_VERSION = " + settings.header.HEADER_VERSION + "\n";
	str += "HEADER_ZIPDISKSIZE = " + settings.header.HEADER_ZIPDISKSIZE + "\n";
	str += "ROM_OUTPUT = " + settings.header.ROM_OUTPUT + "\n\n\n\n\n";


	//writes PASM
	const size_t nodeCount = AST.size();
	
	register size_t registersNeededInTotal = 0; //the number of registers we will need, we pre-calculate this so we can store the data effinetly for CPU hot cache
	std::string dataStr1 = ""; //genaric data string we use for parameters
	bool registersNeedToBeReused = false; //flag for if we are going to have to re-use registers and not just one time use them. Ie when Printing
	
	for (size_t i = 0; i < nodeCount; ++i)
	{
		switch (AST[i].type)
		{
			case AST::ASTNodeType::Halt: str += "HALT ;this will end the program\n"; break;
			case AST::ASTNodeType::InvalidToken_NOP: str += "NOP ;this instruction was generated by a invalid token when lexing the program. Please make sure your Cubasic code is correct.\n"; break;
		
		
			case AST::ASTNodeType::Stack_StoreGeneralRegisterValue: str += "PUSH " + std::to_string(AST[i].Metadata_GRegStoreOnStack.registerIndex) + " ;we are storing a value from this register, so we can override it's register for other uses and not lose this data.\n"; break;
		
			case AST::ASTNodeType::Load_ImmitateValueIntoGeneralRegister: str += "LOADIMM " + AST[i].Metadata_iValueLoadInGReg.value + ", " + std::to_string(AST[i].Metadata_iValueLoadInGReg.registerIndex) + "\n"; break;
		
			case AST::ASTNodeType::System_Print: str += "PRINT " + std::to_string(AST[i].Metadata_systemPrint.registerIndex) + "\n"; break;
		}
	}

	return str;
}